1.编制一个有3个线程的程序。
线程1模拟温度传感器，每隔500毫秒产生并输出一个20-40的随机数，用以表示当前温度。
线程2模拟湿度传感器，每隔400毫秒产生并输出一个70-90的随机数，用以表示当前湿度。
线程3模拟光照传感器，每隔300毫秒产生并输出一个20-80的随机数，用以表示当前光线强度


2.同时线程实现 要求多线程求解某范围5的倍数。
每个线程负责1000范围：线程1找1-1000；
线程 2 找 1001-2000；线程 3 找2001-3000。
编程程序将每个线程找到的5的倍数及时打印


3.有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池用一个
数组int[] arr = {10,5,20,50,100,200,500,800,2,80,300};
创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，
“抽奖箱2”，随机从arr数组中获取奖项元素并打印在控制台
上,格式如下:  抽奖
抽奖箱1 又产生了一个 10 元大奖
抽奖箱2 又产生了一个 100 元大奖
//.....

4.编写一个程序，启动三个线程，
三个线程的名称分别是 A，B，C；
每个线程将自己的名称在屏幕上打印5遍，
打印顺序是ABCABCABCABCABC
==================================================
复习:
Thread常用方法
Thread.currentThread:
getName setName
start:  启动线程  抢CPU    run()
区别？
sleep: Thread类的静态方法  会进入阻塞状态   同时会放弃CPU执行权
不会放弃对象锁   会出现检查行异常  中断异常   当睡眠时间过后
自动就如就绪状态
wait:  Object类的方法  会进入阻塞状态 也会出现检查性异常
 只不过对象锁会释放掉  自己就处于等待池中   必须需要其他人唤醒
 notify 或者notifyAll

setPriority:设置线程优先级 1-10   默认值5   值越高 优先级越高
            这并不是绝对  两个线程同一个时间点 竞争时 概率高点
yield:   放弃本次CPU执行权 进入就绪状态
t.join:  等待T线程执行结束了 再执行当前线程
isAlive()  判断是否存活

线程的五大状态:
创建：当线程刚刚new 出来
就绪：线程准备要开始  需竞争CPU  抢到了才会进入运行状态
运行: 直接运行线程  就是run()
阻塞: 线程由于某些因素导入暂时暂停了线程:
      a. sleep
      b. wait
      c. I/O操作  需要等待用户输入
      d. 添加同步锁  锁如果不释放 其他线程不能运行
      e. 线程某些特定触发条件  t.join
死亡: 线程结束或者中断(1.老死   2.病死的  3.自杀)
      1. run() 正常运行结束
      2. run() 运行时出现异常导入线程中断
      3. 手动调用销毁线程 interrupt() 中断线程


线程同步:
线程安全:  程序无论单线程还是多线程 运行的效果是一致
数据都是准确的
通过同步锁实现线程安全
synchronized(参数){  // 可以描述 同步方法和静态同步方法
}
public synchronized void test(){}     //对象锁  当前对象
等价于

public static synchronized void test(){}  //类锁  当前类对象
等价于
synchronized(类.class){}
===========================================================
在线程中有两种特殊的池:锁池 和等待池
锁池: 通过synchronized  锁主的对象  都会放入锁池  主要是用于保存
同步所使用的锁对象
      synchronized(t对象){}    t对象就放入了锁池
等待池:  调用wait方法之后 释放改对象的对象锁
       直接进入等待池  调用了wait方法线程都会进入等待池
       通过自己是无法重新运行的 所以需要其他线程进行唤醒
       唤醒之后  会进入锁池   表示有资格跟其他线程进行
       抢占锁对象的资格

面试题:
线程的死锁:  多个线程相互持有对方的对象锁，而且都需要等待
对方释放对象锁  但是释放不了   长时间过后就会出现死锁

解决方案:  1. 尽量避免线程持有多个锁
           2.如果有这种需求就需要持有多个锁
             只能尽可能缩短持有锁的时间


线程池: 为了更快创建线程  提高效率 可以使用线程池的方式
1.可缓存线程池:
2.定长线程池:
3.周期性定长线程池:
4.单线程池:

线程中有一种锁 叫Lock锁 类似于Synchronized都是用于实现同步


整理一套自己的语言
Synchronized 和 Lock 锁区别------面试题
1. 结构不同, Synchronized是java关键字是默认提供的
   Lock 是 jdk1.5开始支持  是一个接口
2. 锁的形式不同 Synchronized是隐式锁  Lock是显示锁
Synchronized不需要手动释放锁, 1.wait() 2.syn(){} 同步方法  执行结束
但是Lock 需要手动释放通过 lock()获取锁  unlock()释放锁
   如果没有释放锁 可能会出现死锁
3.
使用Synchronized  线程1和线程2   如果线程1获取了锁  线程2等待
如果线程1持有锁的时间过长  线程2也会等待
使用Lock   如果线程1持有锁的时间过长， 线程2不一定会等待下去

4. 唤醒方式不同:
  Synchronized  可以随机唤醒一个或者唤醒所有 处于等待池的线程
  Lock 可以实现分组唤醒 需要线程  可以更精确唤醒

5. 性能不一样:  资源竞争非常激烈情况下，
Lock性能会高于Synchronized, 竞争不激烈 Synchronized性能偏好
Synchronized 会根据所的竞争情况 可以  升级锁: 从偏向锁-->轻量级锁-->重量级锁
编程可以更加简单

轻量: 耗费资源小的   重量:耗费资源大的



