八种基本数据类型:
java 数据类型几种?  无数种(对象)
java 基本类型： 8种
整形: byte  short  int  long
浮点: float  double
字符: char 一个字符 只能使用单引号  a   种  @
布尔:boolean  true、false
String 字符串类型  不是基本类型
类型转换的问题
1.自动类型提升:  小范围的值 赋值大范围的值
byte===>int
byte b=100;
int i=b;

int==>float
int i=100;
float f=i;

类型之间参与运算
byte +int ==>结果 int
float+double==>结果double
int+double+String==>结果属于字符拼接  一定String类型

2.强制类型转换:  大范围的值  赋值小范围的值
double d3=25.5;
int i3=(int)d3;
int i4=100;
byte b3=100;
byte b4=(byte)i4;

Scanner对象: 是一个可以获取控制台输入数据的对象
Scanner sc=new Scanner(System.in); 参数: 表示 字节输入流
sc.next();  获取一个字符串
sc.nextInt()  获取一个int类型
sc.nextDouble()  获取一个double类型

//为了防止输入数据出现问题(类型不一致的问题)
//可以通过scanner对象的方法 hasXX()  来判断
//sc.hasNextInt();  //判断输入是否是整型
//sc.hasNextDouble(); //判断输入的是否是浮点型
//sc.hasNext();   用的很少

格式化对象: 日期格式化、数字格式化
日期格式化: SimpleDateFormat对象
//获取一个当前系统时间
var s=new Date();  //js
Date d=new Date(); //java

SimpleDateFormat sdf=new SimpleDateFormat(参数)
参数:表示最终日期格式
y  年  M  月  d  天   h 12进制  H 24进制小时
m 分钟  s秒  a 上午下午
"yyyy-MM-dd hh:mm:ss"
String time=sdf.format(日期对象);

2.数字格式化  DecimalFormat
/*
2342342334.234234===> 小数两位
==> 数字 每隔三位加，*/

创建对象
DecimalFormat df=new DecimalFormat(参数);
参数:表示 数字最终的格式
#  0 都是可以表示数字
DecimalFormat df=new DecimalFormat("#.00"); //表示小数是2位
DecimalFormat df=new DecimalFormat("###,###.00"); //每隔三位加逗号
String result=df.format(数字);

选择结构
if(条件){
    操作
}

if(){
}else if(){
}else{
}
switch

switch(){
case 1: 操作1;break;
case 2: 操作2;break;
case 3: 操作3;break;
case 4: 操作4;break;
}

循环结构
不知道循环次数一般使用 while 和  do---while
while   : 先判断 后执行
while(条件){
}
do---while : 先执行一次  后判断
do{
}while(条件)

for
for(int i=0;i<10;i++){
    循环操作
}
for 的四个部分可以不用加   相当于变成死循环
for(;;){
}
有一个400米一圈的操场，一个人要跑10000米，
第一圈50秒，其后每一圈都比前一圈慢1秒，
按照这个规则计算跑完10000米需要多少秒
int time=50;
int sum=0;
for(int i=400;i<=10000;i+=400){  //
    sum+=time;
    time++;
}
初始化循环变量
循环条件
循环变量改变
循环操作


随机生成一个1-100之间的数字num，循环让用户输入猜这个数，
如果用户输入的数字大于num提示输入的数字比较大，
如果用户输入的数字小于num提示输入的数字比较小，
直到用户输入的数字和num相等为止，然后输出用户猜数的总次数

有一个有钱的神经病，他往银行里存钱，
第一天存1元,以后每天比前一天多存50%，完成下列计算任务
a.他存到第几天，当天存的钱会超过10元
b.一个月（30天）后，他总共存了多少钱

有一个400米一圈的操场，一个人要跑10000米，
第一圈50秒，其后每一圈都比前一圈慢1秒，
按照这个规则计算跑完10000米需要多少秒

井里有一只蜗牛，他白天往上爬5米，晚上掉3.5米，井深56.7米
计算蜗牛需要多少天才能从井底到爬出来


1.数组:   存储一系列的值, 长度是固定的, 相同数据类型的
var nums=new Array(6);
nums[0]=值
nums[7]
var nums2=new Array(100,"123",true);
var nums3=["123",123];
int i=100;
int[]  string[]   对象[]
声明一个数组:  数据类型[]   数组名;
int[] nums;
//相当于在内存中分配一个连续的空间保存数据
声明数组并且分配空间:
数据类型[] 数组名=new 数据类型[长度];
int[] nums=new int[5];
声明数组并且分配空间并且赋值:
数据类型[] 数组名=new 数据类型[]{值1,值2,....}
int[] nums=new int[]{1,2,3,4,5};
int[] nums2={1,2,3,4,5};

2.数组遍历: 获取数组中每一个元素
for(int i=0;i<newPrice.length;i++){
      System.out.println(newPrice[i]);
}
//增强for 也可以用于遍历数组
/*  临时变量: 表示数组每次循环出来的数据
for(数据类型 临时变量: 数组或集合){

}

3. 数组排序
a. 借助于工具类  Arrays
Arrays.sort(数组)  将数组的元素进行默认升序排列
如果想改成降序  通过比较器对象实现排序规则
Arrays.sort(数组,比较器对象)   了解

b. 算法 : 冒泡排序   选择排序   插入排序  二分查找  直接排序 快速排序
面试题

冒泡排序: 两两比较排大小
50,10,30,20,70
======第一轮:保证最后一个一定是最大的=======
10 50 30 20 70
10 30 50 20 70
10 30 20 50 70
10 30 20 50 70

======第二轮: 保证50是倒数第二大的========
10 30 20 50
10 20 30 50
10 20 30 50

=====第三轮:保证30 是倒数第三大的=======
10 20 30
10 20 30

======第四轮:保证20是倒数第四大的===========
10 20

for(int i=0;i<数组.length-1;i++){   //控制比较轮数
    for(int j=0;j<数组.length-1-i;j++){ //内层控制 比较的次数 跟轮数相关
        //20  10 50 30
        if(数组[j]>数组[j+1]){  20>10
            //值得互换
        }
    }
}
如何实现值得互换?
   int a=20;
   int b=30;
a. 临时变量
   int temp=a;
   a=b;
   b=temp;
b. 利用加减法  a<==>b
   a=20  b=30
   a=a+b;  a=20+30
   b=a-b;  b=50-30 //20
   a=a-b;  a=50-20 //30
c. 利用乘除法
   a=a*b;  a=20*30
   b=a/b;  b=600/30  //20
   a=a/b;  a=600/20  //30
d. 异或
   a=a^b;
   b=a^b;
   a=a^b;

选择排序:  第一个和其他人比较  然后第二个再跟其他人比较 ...
50,20,-10,5,40
====第一轮:50和20,-10,5,40 比较  保证 第一个一定是最小的 =====
20 50 -10 5 40
-10 50 20 5 40
-10 50 20 5 40
-10 50 20 5 40
====第二轮: 保证第二个是第二小的======================
    20 50 5 40
    5  50 20 40
    5  50 20 40
====第三轮===
       20 50 40
       20 50 40
====第四轮===
          40 50


for(int i=0;i<长度-1;i++){    //外层 控制比较轮数
    for(int j=i;j<长度-1;j++){  //内存控制比较次数
        //第一个值 和所有人比较
        //第二个值 和所有人比较
        if(数组[i]>nums[j+1]){
            值得互换
        }
    }
}
插入排序:  将要排序的数组 分成两个部分: 有序部分和 待插入部分
是一个待插入数据插入到有序数组中,把插入的数据和原来有序数组的数
比较， 遇到第一个比插入数据更大的元素   该元素插入这个位置
50,10,30,5,77
======第一轮 10,50 假设是有序数组=====
10,50   比较前两个
======第二轮 10,50  30 假设是有序数组=====
10 30 50
10 30 50
======第三轮 10,30,50,  5假设是有序数组=====
10 30 5 50
10 5 30 50
5 10 30 50
======第四轮 5,10,30,50,77 假设是有序数组=====
5,10,30,50,77
5,10,30,50,77
5,10,30,50,77
5,10,30,50,77

for(int i=1;i<长度-1;i++){  //控制比较轮数
//比较次数  待插入的元素和有序数组比较  从后往前比较的
    for(int j=i;j>0;j--){
        if(数组[j]<数组[j-1]){
            值得互换
        }
    }
}




二分查找?
排序算法: 稳定性  空间复杂度  时间复杂度