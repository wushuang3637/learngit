构造方法  第一行都会默认添加 super()  如果手动定义了
this() 或者 super()  默认提供的就失效了
this()  和 super() 不可以同时存在   因为两者都需要
放在构造方法第一行

override和overload 区别?  面试题
方法的重写(覆盖) override:
方法名一致   参数一致  返回值一致或者是其子类
访问修饰符不能严于父类(父类==>protected   子类可以是protected或public)
不能比父类抛出更多的异常   ???

方法的重载 overload:  方法名 一致  参数不一致 返回值无关


多态: 同一个引用类型，使用不同的实例而执行不同操作
Dog==>pet    Cat==>pet   print()
      Pet p;
      Pet p=new Dog();
      Pet p=new Cat();
      p.print()   p对象就会根据p实际指向的对象去调用重写后的方法

实现多态的三个前提:
     a.子类和父类实现继承关系   b.方法要重写
     c.父类引用指向了子类对象
       Pet p=new  子类()

final 修饰符:  最终的   可以修饰类  属性 和方法
final 修饰类 的表示最终类  不能被其他类继承
final 修饰方法 表示最终方法  表示方法不能被重写   可以重载
final 修饰属性 表示最终属性 表示常量
       常量要求:1. 名称必须是大写的
                2. 必须要赋初值
                3. 一旦赋值不能再修改了
常量应用场景:   常量去表示  一般不能改变 而且用的比较内容
                1.请求地址  2.驱动地址  3.状态码 4. 错误码
                5.日期信息  等...
常用常量使用方式使用 public static  final  修饰


java中有一种特殊的抽象类,称之为接口 ， 本身是一种功能的约定
没有实现任何功能(里面的所有内容只负责声明 不负责实现)
1. 接口中的所有方法都是抽象方法(有特殊请求)
   dk1.8 之后 支持默认方法   静态方法  可以写实现部分
2. 接口中所有属性都是常量 (默认修饰符 public static final )
3. 通常接口不能被实例化（不能new）
4. 接口和接口之间 支持多继承（接口可以继承多个其他接口）
多实现（类可以实现(implements)多个接口, 如果类没有实现或者没有实现
完 类也是接口或者抽象类）
5. 接口不能定义构造方法

java常见的设计模式（23种设计模式）
设计模式可以分为三大类:
创建型模式: (5种): 工厂模式  抽象工厂模式  单例模式  建造者模式  原始模式
结构型模式: (7种): 代理模式、适配器模式、装饰者模式、桥接模式 等...
行为型模式: (11种):  观察者模式、策略模式、迭代模式  ....等
 单例
单例模式:  一个类只能有一个实例(只能创建出一个对象)  为了节省资源











